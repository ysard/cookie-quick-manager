/*
 *  Cookie Quick Manager: An addon to manage (view, search, create, edit,
 *  remove, backup, restore) cookies on Firefox.
 *  Copyright (C) 2017-2019 Ysard
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Home: https://github.com/ysard/cookie-quick-manager
 */
'use strict';

// IIFE - Immediately Invoked Function Expression
(function(mycode) {

    // The global jQuery object is passed as a parameter
    mycode(window.jQuery, window.vAPI, window, document);

}(function($, vAPI, window, document) {

    // The $ is now locally scoped
    $(function () {

/*********** Events attached to UI elements ***********/
$("#modal_clipboard").on('shown.bs.modal', function () {
    // Capture the focus on textarea and select all its content
    // Event is triggered when the modal is fully shown (CSS transitions included)
    $('#clipboard_textarea').select();

    try {
        // Copy to clipboard
        // API not available on FF63-
        // This is not an event directly generated by an action of a user,
        // so we have to ask a permission to the user in the manifest.
        // See https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/writeText
        navigator.clipboard.writeText($('#clipboard_textarea').val()).then();
    } catch (e) {};
});

/* Bug in FF ? see download().
 $ ("*#file_export").click(function() {
 download($('#domain').val() + ".txt", build_cookie_dump());
});
*/
$("#file_cookie_export").click(function() {
    export_content_to_file(get_concatenated_content(build_cookie_dump()));
});

$("#file_domain_export").click(function() {
    // Build 1 json template for each cookie for the selected domain
    let promise = vAPI.filter_cookies(vAPI.getCookiesFromSelectedDomain());
    promise.then((cookies) => {
        // Make 1 json for each cookie and store it
        // Merge and display templates
        export_content_to_file_wrapper(cookies);

    }, (error) => {
        // No cookie
        console.log({"error:": "No domain selected"});
    });
});

$("#file_all_export").click(function() {
    // Build 1 json template for each cookie in all stores
    let promise = vAPI.filter_cookies(vAPI.get_all_cookies([$('#search_store').val()]));
    promise.then((cookies) => {
        export_content_to_file_wrapper(cookies);
    });
});

$("#clipboard_cookie_export").click(function() {
    // Handle the copy of the current cookie displayed in details zone
    // Build text according to template
    $('#clipboard_textarea').val(get_concatenated_content(build_cookie_dump()));
    // Update title of the dialog box (1 only cookie at the time here)
    $('#modal_clipboard h4.modal-title').text("Export 1 cookie");
    vAPI.ask_permission('clipboardWrite');
});

$("#clipboard_domain_export").click(function() {
    // Build 1 json template for each cookie for the selected domain
    let promise = vAPI.filter_cookies(vAPI.getCookiesFromSelectedDomain());
    display_json_in_clipboard_area(promise);
    vAPI.ask_permission('clipboardWrite');
});

$("#clipboard_all_export").click(function() {
    // Build 1 json template for each cookie in all stores
    let promise = vAPI.filter_cookies(vAPI.get_all_cookies([$('#search_store').val()]));
    display_json_in_clipboard_area(promise);
    vAPI.ask_permission('clipboardWrite');
});

$("#import_file").click(function(event) {
    // Overlay for <input type=file>
    var file_elem = document.getElementById("file_elem");
    if (file_elem) {
        file_elem.click();
    }
    event.preventDefault(); // prevent navigation to "#"
});

$("#file_elem").change(function(event) {
    // File load onto the browser
    var file = event.target.files[0];
    if (!file)
        return;

    var reader = new FileReader();
    reader.onload = function(event) {
        // Restore content
        handleUploadedFile(event.target.result, file.type);
    };
    reader.onerror = function (event) {
        console.error(event.target.error.name);
    };
    reader.readAsText(file);
});

browser.storage.onChanged.addListener(function (changes, area) {
    // Called when the local storage area is modified
    // Here: we handle only 'template' key.

    // Reload template
    if (changes.template !== undefined)
        cookie_clipboard_template = vAPI.templates[changes.template.newValue];
});

/*********** Initializations ***********/

get_options();

});

/*********** Utils ***********/
function get_concatenated_content(templates) {
    // Return string from array of strings
    // According to the current template,
    // make 1 json for each cookie and store it or,
    // return 1 text content with 1 cookie per line.
    return cookie_clipboard_template.left_tag +
        templates.join(cookie_clipboard_template.separator) +
        cookie_clipboard_template.right_tag;
}

function get_templates(cookies) {
    // Return array of templates (strings); 1 for each cookie in the given array
    // Make 1 template for each cookie and store it
    var templates = [];
    for (let cookie of cookies) {
        // Build a template for the current cookie
        templates.push(build_domain_dump(cookie));
    }
    return templates;
}

function export_content_to_file_wrapper(cookies) {
    // Wrapper that chains 3 functions
    // This function is exported to window namespace.
    // Used in contextual Menu (save option),
    // and in click events: #file_domain_export, #file_all_export
    export_content_to_file(get_concatenated_content(get_templates(cookies)));
}

function secure_string(unescaped_string) {
    // Escape double quotes and backslashs only for JSON template
    if (cookie_clipboard_template.name == 'JSON')
        return unescaped_string.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    else if (cookie_clipboard_template.name == 'NETSCAPE')
        return unescaped_string;
    return unescaped_string;
}

function display_json_in_clipboard_area(cookies_promise) {
    // Fill the textarea with the cookies in the given promise
    // This function is exported to window namespace.

    cookies_promise.then((cookies) => {
        // Make 1 json for each cookie
        var templates = get_templates(cookies);
        // Merge and display templates, update title with the number of cookies
        $('#clipboard_textarea').val(get_concatenated_content(templates));
        // Count cookies displayed (not subdomains filtered)
        let title = browser.i18n.getMessage("modalClipboardTitle", templates.length);
        $('#modal_clipboard h4.modal-title').text(title);

    }, (error) => {
        // No cookie
        $('#clipboard_textarea').val('');
        $('#modal_clipboard h4.modal-title').text("Export 0 cookie");
    });
}

function build_cookie_dump() {
    // Return the updated template according to the selected cookie in cookie-list,
    // displayed in details.
    // Data: from the User Interface.

    let cookie = {
        domain: $('#domain').val(),
        name: $('#name').val(),
        path: $('#path').val(),
        value: $('#value').val(),
        session: $('#issession').is(':checked'),
        secure: $('#issecure').is(':checked'),
        httpOnly: $('#httponly').is(':checked'),
        sameSite: $('#samesite').val(), // Can be null if not supported
        storeId: $('#store').val(),
        firstPartyDomain: $('#fpi-domain').val(),
    };

    // If raw is true, return the unix timestamp if the cookie is not a session cookie
    // otherwise, return 0.
    // If raw is false, return human readable date or "At the end of the session" for a
    // session cookie.
    cookie.expirationDate = (!cookie.session) ? $('#expiration_date').data("DateTimePicker").date().unix() : 0;

    // Return the domain status of cookie.
    // If raw is true, return false is cookie is valid for subdomains
    // If raw is false, return "Valid for subdomains" or "Valid for host only".
    // PS:
    //   foo.com => host-only
    //   .foo.com => subdomains
    //   www.foo.com => host-only
    cookie.hostOnly = ($('#domain').val()[0] == '.') ? false : true;

    // Get the updated template according to the given cookie object.
    let template_temp = build_domain_dump(cookie);

    return new Array(template_temp);
    //return JSON.stringify(JSON.parse(template_temp), null, 2);
}

function build_domain_dump(cookie) {
    // Return the updated template according to the given cookie object.
    // Data: from the given cookie object.

    function get_timestamp(raw) {
        // If raw is true, return the unix timestamp if the cookie is not a session cookie
        // otherwise, return 0.
        // If raw is false, return human readable date or "At the end of the session" for a
        // session cookie.
        if (raw) {
            return (!cookie.session) ? cookie.expirationDate : 0;
        }
        return (!cookie.session) ? moment(new Date(cookie.expirationDate * 1000)).format(vAPI.date_format) : "At the end of the session";
    }

    function get_domain_status(raw) {
        // Return the domain status of cookie.
        // If raw is true, return false is cookie is valid for subdomains
        // If raw is false, return "Valid for subdomains" or "Valid for host only".
        // PS:
        //   foo.com => host-only
        //   .foo.com => subdomains
        //   www.foo.com => host-only
        if (raw) {
            // Return false if cookie is also valid for subdomains
            return cookie.hostOnly;
        }
        return (cookie.hostOnly) ? "Valid for host only" : "Valid for subdomains";
    }

    function get_secure_status(raw) {
        // Return the secure status of the cookie
        // If raw is true, return true or false
        if (raw) {
            return cookie.secure;
        }
        return (cookie.secure) ? "Encrypted connections only" : "Any type of connection";
    }

    // Make a local copy of the template
    var template_temp = cookie_clipboard_template.template;

    var params = {
        '{HOST_RAW}': vAPI.getHostUrl(cookie),
        '{DOMAIN_RAW}': cookie.domain,
        '{NAME_RAW}': secure_string(cookie.name),
        '{PATH_RAW}': cookie.path,
        '{CONTENT_RAW}': secure_string(cookie.value),
        '{EXPIRES}': get_timestamp(false),
        '{EXPIRES_RAW}': get_timestamp(true),
        '{ISSECURE}': get_secure_status(false),
        '{ISSECURE_RAW}': get_secure_status(true),
        '{ISHTTPONLY_RAW}': cookie.httpOnly,
        '{SAMESITE_RAW}': cookie.sameSite ? cookie.sameSite : "no_restriction",
        '{ISDOMAIN}': get_domain_status(false),
        '{ISDOMAIN_RAW}': !cookie.hostOnly,
        '{STORE_RAW}': cookie.storeId,
        '{FPI_RAW}': cookie.firstPartyDomain ? cookie.firstPartyDomain : "", // This attr is absent on old FF
    };

    // Replace variables in template
    for (let key_pattern in params) {
        // Get rid of $ forms in the replacement string
        // Thx to https://stackoverflow.com/questions/28102491/javascript-better-way-to-escape-dollar-signs-in-the-string-used-by-string-prot
        // http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
        template_temp = template_temp.replace(key_pattern, function () {return params[key_pattern]});
    }
    return template_temp;
}

function download(filename, text) {
    /* bug for Firefox in panel ?
     * This file is opened in place of the current window instead of downloaded...
     * TODO: This function can be replaced with an iframe like in the event:
     * $("#file_export").click(function() ...
     */
    var element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
    element.setAttribute('download', filename);

    element.style.display = 'none';
    document.body.appendChild(element);

    element.click();

    document.body.removeChild(element);
}

function export_content_to_file(content) {
    // Due do FF bug (cf download() function)
    // We have to create an iframe to propose a file to the user

    // Choose the right filename/filetype according to the selected export format
    let cookie_filename;
    let cookie_filetype;
    if (cookie_clipboard_template.name == 'JSON') {
        cookie_filename = 'cookies.json';
        cookie_filetype = 'application/json';
    } else {
        cookie_filename = 'cookies.txt';
        cookie_filetype = 'text/plain';
    }

    var f = document.createElement('iframe');
    f.style.position = 'fixed';
    f.style.left = f.style.top = '-99px';
    //f.style.width = f.style.height = '99px';
    f.srcdoc = '<a download="' + cookie_filename + '" target="_blank">' + cookie_filename + '</a>';
    f.onload = function() {
        var blob = new Blob([content], {type: cookie_filetype});
        var a = f.contentDocument.querySelector('a');
        a.href = f.contentWindow.URL.createObjectURL(blob);
        a.click();
        // Removing the frame document implicitly revokes the blob:-URL too.
        setTimeout(function() { f.remove(); }, 2000);
    };
    document.body.appendChild(f);
}

function handleUploadedFile(content, mimetype) {
    // Take a file content and dispatch it to the good parser
    // Handle errors due to parsers.

    browser.runtime.getBrowserInfo().then((browser_info) => {

        // Detect Firefox version:
        // -> sameSite attribute is available on Firefox 63+=
        // {name: "Firefox", vendor: "Mozilla", version: "60.0.1", buildID: ""}
        let firefox_version = parseInt(browser_info.version.split('.')[0], 10);
        let cookies_promises;

        // Detect format based on MimeType: JSON or Netscape
        if (mimetype == "application/json")
            cookies_promises = parseJSONFile(content, firefox_version);
        else if (mimetype == "text/plain")
            cookies_promises = parseNETSCAPEFile(content, firefox_version);
        else {
            console.error("handleUploadedFile:: MimeType not supported", mimetype);
            return;
        }

        cookies_promises.then((promises) => {
            add_cookies(promises);
        }, (error) => {
            // Parser error (JSON)
            set_info_text(browser.i18n.getMessage("cookieRestoredError", error));
            $('#modal_info').modal('show');
        }).catch((error) => {
            console.error("Unexpected error:", error);
        });
    });
}

function parseNETSCAPEFile(content, firefox_version) {
/* Parse Netscape file and return a list of cookies.set promises.
 * NOTE: About default values. The netscape format is less rich than the JSON format,
 * thus some features of the cookies are lost and are replaced by default values when inserting.
 *
 * - sameSite: 'no_restriction'.
 * - httpOnly: false (cookie accessible from JS code).
 * - storeId: current selected context.
 * - firstPartyDomain: empty string (No way to know which is the FPI domain).
 *
 * NOTE: About Netscape file format (tabulated only):
 *  0             1               2           3               4              5           6
 * '{DOMAIN_RAW}\t{ISDOMAIN_RAW}\t{PATH_RAW}\t{ISSECURE_RAW}\t{EXPIRES_RAW}\t{NAME_RAW}\t{CONTENT_RAW}'
 */

    return new Promise((resolve, reject) => {

        // Build cookies
        vAPI.FPI_detection().then(() => {
            // Parse lines of the file
            let lines = content.split(/\r\n|\n/);
            let line;

            let promises = [];
            for(let i=0, n=lines.length; i < n; i++){
                // Tabulated file only
                line = lines[i].split('\t');

                // Skip empty lines or comments
                if (line.length != 7 || line[0] == '#') {
                    console.error(`Error: Skip line ${i + 1}`);
                    continue;
                }

                // Get data from columns
                let params = {
                    domain: line[0],
                    hostOnly: (line[1].toLowerCase() == "true"),
                    path: line[2],
                    secure: (line[3].toLowerCase() == "true"),
                    name: line[5],
                    value: line[6],
                };

                if ($('#search_store').val() != "all")
                    // If context is all: let the browser select the default context
                    params.storeId = $('#search_store').val();


                if (line[4] != 0) {
                    // expirationDate is not provided for session cookies
                    // If omitted, the cookie becomes a session cookie.
                    let expirationDate = parseInt(line[4], 10);

                    if (isNaN(expirationDate)) {
                        console.error(`Error during the parse of expiration date: Skip line ${i + 1}`);
                        continue;
                    } else if (expirationDate <= ((Date.now() / 1000|0) + 1))
                        // Refuse expired cookies
                        continue;

                    params.expirationDate = expirationDate;
                }

                if (vAPI.FPI !== undefined)
                    // FPI enabled or disabled but supported
                    // firstPartyDomain can be set
                    // If it is not a FPI cookie, set empty string ""
                    params.firstPartyDomain = "";

                // Set Url
                params.url = vAPI.getHostUrl(params); // use attrs: secure, domain, path

                // hostOnly flag is automatically set according to the presence
                // of the leading point in the url
                delete params["domain"];

                // Not an expected param
                delete params["hostOnly"];

                promises.push(browser.cookies.set(params));
            }
            resolve(promises);
        });
    });
}

function parseJSONFile(content, firefox_version) {
    // Parse JSON file and return a list of cookies.set promises.

    return new Promise((resolve, reject) => {

        try {
            // Throw SyntaxError if JSON is not correctly formatted
            var json_content = JSON.parse(content);
        } catch (error) {
                // PS: if (error instanceof SyntaxError)
                console.error(error);
                reject(error);
                return;
        }

        // Build cookies
        vAPI.FPI_detection().then(() => {
            //console.log(vAPI.FPI);

            let promises = [];
            for (let json_cookie of json_content) {
                let params = {
                    url: json_cookie["Host raw"],
                    name: json_cookie["Name raw"],
                    value: json_cookie["Content raw"],
                    path: json_cookie["Path raw"],
                    httpOnly: (json_cookie["HTTP only raw"] === 'true'),
                    secure: (json_cookie["Send for raw"] === 'true'),
                    storeId: (json_cookie["Private raw"]  === 'true') ? 'firefox-private' : 'firefox-default',
                };

                // -> sameSite attribute is available on Firefox 63+=
                if (firefox_version >= 63 && json_cookie["SameSite raw"] !== undefined) {
                    params['sameSite'] = json_cookie["SameSite raw"];
                }

                if (json_cookie["Store raw"] !== undefined) {
                    params['storeId'] = json_cookie["Store raw"];
                }

                // expirationDate is not provided for session cookies
                // If omitted, the cookie becomes a session cookie.
                if (json_cookie["Expires raw"] != "0") {
                    // Refuse expired cookies
                    let expirationDate = parseInt(json_cookie["Expires raw"], 10);
                    if (expirationDate <= ((Date.now() / 1000|0) + 1))
                        continue;

                    params['expirationDate'] = expirationDate;
                }

                if (vAPI.FPI !== undefined) {
                    // FPI enabled or disabled but supported
                    // firstPartyDomain can be set
                    // If it is not a FPI cookie, set empty string ""
                    params['firstPartyDomain'] = (json_cookie["First Party Domain"]) ? json_cookie["First Party Domain"] : "";
                }

                promises.push(browser.cookies.set(params));
            }
            resolve(promises);
        });
    });
}

function add_cookies(promises) {
    // Take a list of cookie.set promises and execute them
    // Cookies are protected on the fly according to the option "Protect cookies during import"
    // Handle errors due to the insertion of cookies.

    let cookies_number = promises.length;

    // Handle import_protected_cookies global option
    var get_settings = browser.storage.local.get({
        import_protected_cookies: false
    });

    get_settings.then((items) => {
        //console.log(items);
        //console.log(vAPI.FPI);

        return vAPI.add_cookies(Promise.all(promises), items.import_protected_cookies);

    })
    .then((ret) => {
        // Display modal info
        set_info_text(browser.i18n.getMessage("cookieRestoredSuccess", cookies_number));
        // Actualize interface
        $("#actualize_button").click();
        $('#modal_info').modal('show');
    }, (error) => {
        console.error({AddError: error});
        set_info_text(browser.i18n.getMessage("cookieRestoredSingleError", error));
        // If null: no error but no save
        $("#actualize_button").click();
        $('#modal_info').modal('show');
    });
}

function set_info_text(content) {
    $('#info_text').html(content);
}

function get_options() {
    // Get options from storage
    // Init cookie_clipboard_template array in global context

    let get_settings = browser.storage.local.get({
        template: 'JSON',
    });
    get_settings.then((items) => {
        //console.log({storage_data: items});
        cookie_clipboard_template = vAPI.templates[items.template];
    });
}


var cookie_clipboard_template;

window.display_json_in_clipboard_area = display_json_in_clipboard_area;
window.export_content_to_file_wrapper = export_content_to_file_wrapper;
}));
